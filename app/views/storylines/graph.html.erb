<h2 class="floating_header"><%= link_to "Storeys", storylines_path %></h2>

<div id="viz_wrapper"></div>

<%= javascript_include_tag "d3.v3.min" %>
<%= javascript_include_tag "colorbrewer" %>

<script>
// To fade out controls when the mouse/finger is idle for 10 seconds
$().ready(function() {
  var timer;
  function fadeoutControls() {
    $('#graph_navigation').fadeOut();
    $('.floating_footer').fadeOut();
    $('#feedback_panel').fadeOut();
    $('#user_panel').fadeOut();
  }
  function fadeinControls() {
    $('#graph_navigation').show();
    $('.floating_footer').show();
    $('#feedback_panel').show();
    $('#user_panel').show();
  }
  $("svg").bind('mousemove click touchstart', function() {
    if (timer) {
      clearTimeout(timer);
      timer = 0;
    }
    fadeinControls();
    timer = setTimeout(fadeoutControls, 10000);
  });
});

var isiPad = navigator.userAgent.match(/iPad/i) != null;

function d3viz() {
  
  // For use in updating the graph from server
  var real_to_index = {}; // Hash from real id to the index of that node
  var self_added_lines = {}; // TODO Need something better than this to avoid WebSockets double creation. If someone else adds the exact same text, it won't show.
  
  //
  // Add/Edit Nodes
  //
  var isDraggable = false; // Whether we're in node-draggable mode or node link creation mode
  var isCollapsible = true;
  var activeNode = null, click_time = 0;
  var startNode = null, endNode = null;
  var lineData = []; // Stores backing line coordinates
  var line = d3.svg.line().x(function(d) { return d[0] }).y(function(d) { return d[1] }).interpolate('linear');
  var pauseWebSockets = false;
  $().ready(function() {  
    $('#edit_dialog').hide();
    $('#edit_dialog_button').click(function() {
      if (activeNode.dashed) {
        pauseWebSockets = true;
        jnodes.push({"name": $('#edit_dialog_text').val(), "group": jnodes[activeNode.parentIndex].group+1, "stroke": 2, "age": 0.01}); // Must be > 0 because 0 is false in Javascript
        var nodeIndex = jnodes.length - 1;
        jlinks.push({"source": activeNode.parentIndex, "target": nodeIndex, "value": 2 + ($('#edit_dialog_text').val().length/50)});
        jnodes.push({"name": "+", "group": jnodes[activeNode.parentIndex].group+1, "stroke": 2, "real_id": "p"+nodeIndex, "parentIndex": nodeIndex, "dashed": true});
        jlinks.push({"source": nodeIndex, "target": jnodes.length-1, "value":  0.8 + ($('#edit_dialog_text').val().length+50)/100});
        // Update
        self_added_lines[$('#edit_dialog_text').val()] = true; // Prevent WebSockets from creating this node again
        console.log(jnodes);
        $.post("<%= graph_add_storylines_path %>",
          { "parent_id": jnodes[activeNode.parentIndex].real_id, "line": $('#edit_dialog_text').val() },
          function(data) {
            lastIndex = nodeIndex;
            for(var i = 0; i < data.lines.length; i++) {
              if (i == 0) { // Update initial added node
                jnodes[nodeIndex].name = data.lines[0];
                jnodes[nodeIndex].real_id = data.ids[0];
                real_to_index[data.ids[0]] = nodeIndex;
              }
              else { // Add child nodes, plus signs, and edges
                jnodes.push({"name": data.lines[i], "group": jnodes[lastIndex].group+1, "stroke": 2, "real_id": data.ids[i], age: 0.01});
                var newIndex = jnodes.length - 1;
                real_to_index[data.ids[i]] = newIndex;
                jlinks.push({"source": lastIndex, "target": newIndex, "value": 2 + (data.lines[i].length/50)});
                jnodes.push({"name": "+", "group": jnodes[lastIndex].group+1, "stroke": 2, "parentIndex": newIndex, "real_id": "p"+newIndex, "dashed": true});
                jlinks.push({"source": newIndex, "target": jnodes.length-1, "value": 0.8 + (data.lines[i].length+50)/100});
                lastIndex = newIndex;
              }
            }
            // Only redraw graph if new items were added
            if (!(data.lines[0] == $('#edit_dialog_text').val() && data.lines.length == 1)) {
              supdate(isDraggable);
            }
            pauseWebSockets = false;
          }, "json");
      }
      else{
        activeNode.name = $('#edit_dialog_text').val();
        // Update
        $.post("<%= graph_update_storylines_path %>",
          { "id": activeNode.real_id, "line": $('#edit_dialog_text').val() },
          function(data) { } );
      }
      $('#edit_dialog').hide();
      supdate(isDraggable);
    });
    $('#edit_close_button').click(function() {
      $('#edit_dialog').hide();
    });
  });

  //
  // Connect Nodes Together By Dragging a Line From One to The Other
  //
  $().ready(function() {
    // Connect two nodes to each other
    // Line dragging in the background
    $("svg").bind('mouseup', function(e) {
      startNode = null;
      endNode = null;
      visback.selectAll('path.mylines').remove();
    });
    $("#viz_wrapper").bind('mousemove', function(e) {
      if (!isDraggable && startNode != null) {
        var transString = $('svg g.main').attr('transform');
        $('svg g.back').attr('transform', transString);
        var regex = /translate\(([\-\d\.]+),([\-\d\.]+)\)scale\(([\-\d\.]+)\)/g;
        var matches = regex.exec(transString);
        // console.log(transString);
        if (matches == null) {
          lineData[1] = [e.offsetX, e.offsetY];
        } else {
          lineData[1] = [(e.offsetX - parseInt(matches[1])) / parseFloat(matches[3]), (e.offsetY - parseInt(matches[2])) / parseFloat(matches[3])];
        }
        visback.selectAll('path.mylines').attr('d', line(lineData));
        // console.log(lineData[1]);
      }
    });
  });
  function nodeMouseDown(d) {
    if (!isDraggable) {
      startNode = d;
      lineData[0] = [startNode.x, startNode.y];
      visback.selectAll('path.mylines').data([lineData]).enter().append('path').attr("stroke", "maroon").attr("stroke-width", 1).attr('class', 'mylines');
      console.log("down" + d.name);      
    }
  }
  function nodeMouseUp(d) {
    // TODO Make this work on the iPad
    // TODO Don't allow existing links
    // TODO Dynamic link length - now it's either too long or too short
    if (!isDraggable) {
      endNode = d;
      console.log("up" + d.name);
      if (startNode != endNode) { // Prevent self-loops
        // Add link in d3
        jlinks.push({"source": real_to_index[startNode.real_id], "target": real_to_index[endNode.real_id], "value": 5});
        supdate();
        // Post to server
        $.post("<%= graph_link_storylines_path %>", { "from_id": startNode.real_id, "to_id": endNode.real_id }, function(data) {});
      }
      startNode = null; endNode = null;
    }
  }

  //
  // Dialog Box Functionality
  //
  function openEditDialog(d) {
    activeNode = d;
    if (activeNode.dashed) {
      $('#edit_dialog_button').val("Add");
      $('#edit_dialog_text').val("");
    }
    else {
      $('#edit_dialog_button').val("Edit");
      $('#edit_dialog_text').val(d.name);
    }
    if (activeNode.dashed || (d.age && d.age < 1)) {
      $('#edit_dialog').show();
      $('#edit_dialog_text').focus();
      click_time = new Date().getTime();
    }
    else {
      // notice("Sorry, but you shouldn't edit this :(");
      // Highlight node in red and then fade back to original color
      var selectedNode = d3.select(this);
      selectedNode.transition().duration(300).style("stroke", "red");
      selectedNode.transition().delay(800).duration(700).style("stroke", color(d.group));
    }
  }
  function hideDialog(e) {
    if (!$(e.target).parents().hasClass('edit_dialog') && new Date().getTime() - click_time > 200) {
      $('#edit_dialog').hide();
      $(document).unbind('click.graph_dialog');
    }
  }
  if (!isiPad) {
    $("#viz_wrapper").click(hideDialog);
  }

  //
  // Collapsible Functionality
  //
  function collapseTree(d) {
    // Make sure this node is not editable (age) and that it isn't a + node (dashed)
    if (isCollapsible && startNode == null && !((d.age && d.age < 1)) && !d.dashed) {
      if (!d.collapsed) {
        d.collapsed = true;
        supdate(isDraggable);
      } else {
        d.collapsed = false;
        supdate(isDraggable);
      }
    }
  }

  //
  // Top Left Icon Functionality
  //
  $().ready(function() {
    $('#recenter').live('click', function() {
      xlate = [(-jnodes[0].x)*scaly + $('svg').width()/2, (-jnodes[0].y)*scaly + $('svg').height()/2];
      vis.attr("transform", "translate("+xlate+")scale(" + scaly + ")");
      zoomy.translate(xlate);
    });
    $('#drag').live('click', function() {
      if (isDraggable) {
        $('#drag').html('<%= image_tag("move.svg", :border => 0) %>').attr('title', 'Switch to Dragging Mode');
        isDraggable = false;
        supdate(false);
        // alert("disabled!");
      } else {
        $('#drag').html('<%= image_tag("link.svg", :border => 0) %>').attr('title', 'Switch to Linking Mode');
        isDraggable = true;
        supdate(true);        
      }
    });
  });

  //
  // D3 Starts Here! Original code courtesy of http://bl.ocks.org/1846692
  //
  var w = 1280,
      h = 720,
      color = <%= @graph_theme %>,
      jnodes, jlinks,
      link, node, trilink,
      nodeCircles, nodePaths, linkObjs, trilinkObjs;
  
  var vis = d3.select("#viz_wrapper").append("svg:svg")
      .attr("width", "100%")
      .attr("height", "100%");

  // Pan and Zoom http://groups.google.com/group/d3-js/browse_thread/thread/346e75ba083fba4b
  var scaly = 1.0;
  var zoomy = d3.behavior.zoom()
    // .xExtent(function() {
    //   range = d3.extent(jnodes, function(d) { return d.x }); return [range[0], range[1], $('#viz_wrapper').width()]; 
    // } )
    // .yExtent(function() {
    //   range = d3.extent(jnodes, function(d) { return d.y }); return [range[0], range[1], $('#viz_wrapper').height()];
    // } )
    .scaleExtent([1.0/8, 8])
    .on("zoom", function() {
      vis.attr("transform", "translate(" + d3.event.translate + 
        ")scale(" + d3.event.scale + ")");
      scaly = d3.event.scale;
    });

  vis.append("rect") 
    .attr("width", "100%") 
    .attr("height", "100%") 
    .attr("fill", "#fcfcfc") 
    .call(zoomy);
  var visback = vis.append("g").attr('class', 'back'); // Layer behind nodes and lines
  vis = vis.append("g").attr('class', 'main');

  // Force Layout
  var force = self.force = d3.layout.force()
    .gravity(.05)
    .distance(function(d) { return 80 * d.value })
    .charge(function(d) { if (d.dashed) return -5000; else return -5000/(d.group/2+1); })
    .size([w, h]);
  force.on("tick", function(e) {
    link.attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; });

    trilink.attr("class", "tlink")
      .attr('d', function(d) { 
        var x = (d.source.x + d.target.x)/2, y = (d.source.y + d.target.y)/2;
        if (!d.target.dashed) {
          return 'M ' + x +' '+ y + ' l 4 4 l -8 0 z';
        } else {
          return 'M 0 0 z';
        }
      })
      .attr("transform", function(d) {
        var x = (d.source.x + d.target.x)/2, y = (d.source.y + d.target.y)/2;
        var deg = Math.atan((d.target.y - d.source.y) / (d.target.x - d.source.x)) * 180 / Math.PI;
        if (d.target.x < d.source.x) {
          deg -= 90;
        } else {
          deg += 90;
        }
        return "rotate("+deg+", "+x+", "+y+")";
      });

    // node.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
    node.attr("transform", function(d) {
      if(d.index==0){
          damper = 0.1;
          d.x = d.x + (w/2 - d.x) * (damper + 0.71) * e.alpha;
          d.y = d.y + (h/2 - d.y) * (damper + 0.71) * e.alpha;
      }
      //start is initiated when importing nodes from XML
      if(d.start === true){
          d.x = w/2;
          d.y = h/2;
          d.start = false;
      }
      return "translate("+d.x+","+d.y+")";
    });
  });

  // Ajax Call
  d3.json("<%= storyline_path(@storyline, :format => 'json') %>", function(json) {
    jnodes = json.nodes;
    jlinks = json.links;
    $(jnodes).each(function(index, node) {
      if (!node.dashed) {
        real_to_index[node.real_id] = index;   
      }
    });
    supdate();
  });

  //
  // WebSockets Support
  //
  var dispatcher = new WebSocketRails('<%= Stories::Application.config.base_url %>/websocket');
  var posts = [];
  // Whenever new posts come in, they get pushed onto a queue to be processed
  channel = dispatcher.subscribe('story');
  channel.bind('new', function(post) {
    console.log('a new line '+post.line+' (prev id '+post.prev+') arrived!');
    posts.push(post);
  });
  // The function that processes websocket posts. Runs every 100ms, and can be disabled.
  function createWebsocketPosts() {
    if (!pauseWebSockets && posts.length > 0) {
      var post = posts.shift();
      console.log('processing ' +post.line+'!');
      if (!(post.real_id in real_to_index) && (post.prev in real_to_index) && !(post.line in self_added_lines)) { // If we haven't seen this node before (prevent adding to self)
        console.log(real_to_index);
        console.log(post);
        
        // Add the node
        var prevNode = jnodes[real_to_index[post.prev]]; // Get previous node
        var node = { "chargeless": true, "real_id": post.real_id, "name": post.line, "is_new": true, "group": prevNode.group + 1, "stroke": 2 };
        jnodes.push(node);
        real_to_index[node.real_id] = jnodes.length - 1;
        
        // Add + Node
        jnodes.push({ "chargeless": true, "name": "+", "group": node.group, "stroke": 2, "real_id": "p"+node.real_id, "parentIndex": real_to_index[node.real_id], "dashed": true})
        jlinks.push({ "source": real_to_index[node.real_id], "target": jnodes.length-1, "value": 0.8 + (node.name.length+50)/100 });

        // Add the link
        jlinks.push({ "source": real_to_index[post.prev], "target": real_to_index[node.real_id] , "value": 2 + node.name.length / 50 });
        force.charge(function(d) { 
          if (d.chargeless) {
            d.chargeless = false;
            return 0;
          } else {
            if (d.dashed) return -5000; else return -5000/(d.group/2+1);        
          }
        })
        supdate(isDraggable);
      }
    }
  }
  setInterval(createWebsocketPosts, 100);
  
  //
  // Grabs a new JSON, determines which nodes are new and adds them to the existing graph (Alternative to WebSockets)
  //
  var jsonUpdateTimeout = null;
  function jsonUpdate() {
    d3.json("<%= storyline_path(@storyline, :format => 'json') %>", function(json) {
      var new_nodes = {};
      $(json.nodes).each(function(index, node) {
        if (!node.dashed && !(node.real_id in real_to_index)) { // If we haven't seen this real_id before
          node["is_new"] = true;
          jnodes.push(node);
          real_to_index[node.real_id] = jnodes.length - 1;
          new_nodes[node.real_id] = true;
          // Add + Node
          jnodes.push({ "name": "+", "group": node.group, "stroke": 2, "real_id": "p"+node.real_id, "parentIndex": real_to_index[node.real_id], "dashed": true})
          jlinks.push({ "source": real_to_index[node.real_id], "target": jnodes.length-1, "value": 0.8 + (node.name.length+50)/100 })
        }
      });
      // Add links by determining the new indices of each node
      $(json.links).each(function(index, link) {
        if (json.nodes[link.source].real_id in new_nodes || json.nodes[link.target].real_id in new_nodes) { // If either the source or target node is new
          jlinks.push({ "source": real_to_index[json.nodes[link.source].real_id], "target": real_to_index[json.nodes[link.target].real_id] , "value": link.value })
        }
      });
      supdate();
      jsonUpdateTimeout = setTimeout(jsonUpdate, 30000);
    });
  }
  $().ready(function() {
    $('#loading').click(function() {
      if ($('#loading img').hasClass('animate')) {
        $('#loading img').removeClass('animate');
        clearTimeout(jsonUpdateTimeout);
      }
      else {
        $('#loading img').addClass('animate');
        clearTimeout(jsonUpdateTimeout);
        jsonUpdate();
      }    
    });    
  });

  //
  // Node and Edge Update Helpers
  //
  function supdate(draggableNodes) {
    if (typeof(draggableNodes) === 'undefined') draggableNodes = false;

    var jnodes_temp = filterNodes();

    force.nodes(jnodes).links(jlinks).start(); // Restart force layout

    // Link Additions
    linkObjs = vis.selectAll("line.link")
      .data(jlinks)
      .enter().insert("svg:line", ":first-child");
    linkUpdateHelper();
    vis.selectAll("line.link").data(jlinks).exit().remove();
  
    // Link Updates
    linkObjs = vis.selectAll("line.link")
      .data(jlinks)
      .selectAll("line");
    linkUpdateHelper();

    // Link Triangles Additions
    trilinkObjs = vis.selectAll("path.tlink")
      .data(jlinks)
      .enter().insert("path", ":first-child");
    trilinkUpdateHelper();
    vis.selectAll("path.tlink").data(jlinks).exit().remove();

    // Link Triangles Updates
    trilinkObjs = vis.selectAll("path.tlink")
      .data(jlinks)
      .selectAll("path");
    trilinkUpdateHelper();

    // Node Additions
    node = vis.selectAll("g.node")
      .data(jnodes_temp, function(d) { return d.index; })
      .enter().append("svg:g")
      .attr("class", "node");
    
    if (draggableNodes) {
      node.call(force.drag);
    } else { // Alternatively, https://groups.google.com/forum/?fromgroups=#!topic/d3-js/-HcNN1deSow
      node.on("mousedown.drag", null);
      node.on("touchstart.drag", null);      
    }

    nodeCircles = node.append("circle");
    nodePaths = node.append("path");
    updateHelper();
    vis.selectAll("g.node").data(jnodes_temp, function(d) { return d.index; }).exit().remove();
  
    // Node Updates
    node = vis.selectAll("g.node")
      .data(jnodes_temp, function(d) { return d.index; });

    // console.log(jnodes);

    if (draggableNodes) {
      node.call(force.drag);
    } else {
      node.on("mousedown.drag", null);
      node.on("touchstart.drag", null);      
    }

    nodeCircles = node.selectAll("circle");
    nodePaths = node.selectAll("path");
    updateHelper();

    link = vis.selectAll("line.link");
    trilink = vis.selectAll("path.tlink");
    node = vis.selectAll("g.node");
  }

  // Hide collapsed nodes
  function filterNodes() {
    var tempNodes = [];
    var filteredIndices = {}; // Nodes that got filtered
    for (var j = 0; j < 2; j++) { // Do this filtering twice to cover the + nodes which may be listed first
      for (var i = 0; i < jlinks.length; i++) {
        var link = jlinks[i];
        if (filteredIndices[link.source.index] == true || link.source.collapsed) {
          filteredIndices[link.target.index] = true;
        }
      }
    }
    // Return the nodes that didn't get filtered
    for (var i = 0; i < jnodes.length; i++) {
      if (!filteredIndices[i]) {
        tempNodes.push(jnodes[i]);
      }
    }
    return tempNodes;
  }

  function linkUpdateHelper() {
    linkObjs.attr("class", "link")
      .attr("x1", function(d) { return d.source.x; })
      .attr("y1", function(d) { return d.source.y; })
      .attr("x2", function(d) { return d.target.x; })
      .attr("y2", function(d) { return d.target.y; });
  }

  function trilinkUpdateHelper() {
    trilinkObjs.attr("class", "tlink")
      .attr('d', function(d) { 
        var x = (d.source.x + d.target.x)/2, y = (d.source.y + d.target.y)/2;
        if (!d.target.dashed) {
          return 'M ' + x +' '+ y + ' l 4 4 l -8 0 z';
        } else {
          return 'M 0 0 z';
        }
      })
      .attr("transform", function(d) {
        var x = (d.source.x + d.target.x)/2, y = (d.source.y + d.target.y)/2;
        var deg = Math.atan((d.target.y - d.source.y) / (d.target.x - d.source.x)) * 180 / Math.PI;
        if (d.target.x < d.source.x) {
          deg -= 90;
        } else {
          deg += 90;
        }
        return "rotate("+deg+", "+x+", "+y+")";
      });
  }

  function updateHelper() {

    function nodeStrokeColor(d) {
      if (d.collapsed) {
        return d3.rgb(color(d.group)).brighter().toString();
      } else {
        return color(d.group);
      }
    }

    // Set Circle
    var transitionNodeCircles = nodeCircles
      .attr("class", "circle")
      .attr("r", 50)
      .attr("fill", "white")
      .attr("stroke", nodeStrokeColor)
      .attr("stroke-width", function(d) { return d.stroke+"px"; })
      .attr("stroke-dasharray", function(d) { if (d.dashed) return "5 3"; } );
    if (isiPad) {
      nodeCircles.on("touchend", openEditDialog).on("click", openEditDialog);
    }
    else {
      nodeCircles.on("click", openEditDialog);
      nodeCircles.on("click.collapse", collapseTree);
    }

    // Connect two nodes to each other
    nodeCircles.on("mousedown", nodeMouseDown);
    nodeCircles.on("mouseup", nodeMouseUp);

    // Highlight on mouseover
    nodeCircles.on("mouseover", function(d) {
      var selectedNode = d3.select(this);
      selectedNode.transition().duration(100).style("stroke", "orange");
    });
    nodeCircles.on("mouseout", function(d) {
      var selectedNode = d3.select(this);
      selectedNode.transition().duration(200).style("stroke", nodeStrokeColor);
    });
  
    node.selectAll("text").remove(); // Clear all existing text
  
    // Set Text
    node.each(function(d) {
      var curr = d3.select(this);
      var words = d.name.replace(/^\s+|\s+$/g,"").split(" ");
      var lineArray = [];
      var numWords = Math.sqrt(words.length) | 0 + 1;
      var numLines = Math.ceil(words.length / numWords);
      var fontSize = 16;
      var yOffset = -numLines*fontSize/2;
      if (d.dashed) {
        fontSize = 24;
        yOffset -= 9;
      }
      var textElt = curr.append("svg:text")
       .attr("class", "nodetext")
       .attr("dx", 0).attr("y", yOffset+"px")
       .attr("text-anchor", "middle")
       .style("font-size", fontSize+"px");
      var index = 0;
      while(index < words.length) {
       var tempWords = "";
       for (var j = 0; j < numWords; j++) {
         if (j + index < words.length) {
           tempWords += words[j+index]+" ";
         }
       }
       var tempNode = textElt.append("svg:tspan").text(tempWords).attr("dy", "1em").attr("x", 0);
       index += numWords;
      }

      // Set initial radius for new nodes to be small at first
      if (d.is_new) {
        d.radius = 10;
        d.true_radius = Math.max(textElt.node().getBBox().width, textElt.node().getBBox().height)*1.1 / 2 + 8;
      } else {
        d.radius = Math.max(textElt.node().getBBox().width, textElt.node().getBBox().height)*1.1 / 2 + 8;        
      }
    });
   
    // Set Real Radius (can only do this after we've determined how large the text box is)
    nodeCircles.attr("r", function(d) { 
      return d.radius;        
    });

    // Animate Radius Increase For New Nodes
    transitionNodeCircles.transition().duration(1000).attr("r", function(d) {
      if (d.is_new) {
        d.radius = d.true_radius;
      }
      return d.radius;
    }).transition().duration(1000).attr("stroke", function(d) { 
      if (d.is_new) {
        return "rgb(0,0,0)";
      }
      else {
        return color(d.group);
      }
    })
    .transition().delay(1000).duration(10000).attr("stroke", nodeStrokeColor); // Transition to highlight new nodes in black;
   
    nodeCircles.selectAll().each(function(d) {
      d.is_new = false;
    });

    // Set Arc
    nodePaths
      .attr("d", d3.svg.arc()
       .innerRadius(function(d) { if (d.age) return d.radius+d.stroke+1; else return 0; })
       .outerRadius(function(d) { if (d.age) return d.radius+d.stroke+3; else return 0; })
       .startAngle(0).endAngle(function(d) { if (d.age) return Math.max(0, 1-d.age)*2*Math.PI; else return 0; }))
      .style("fill", function(d) { return color(d.group); })
      .style("stroke", function(d) { return color(d.group); });
      
    // Animate Age
    nodePaths.transition().duration(function(d) { return (1.0-d.age) * 60000; }).attrTween("d", function(d) { 
        // console.log(d.age);
        var start = 0;
        if (d.age) start = Math.max(0, 1-d.age);
        var i = d3.interpolateNumber(start, 0);
        return function(t) {
          d.age = 1 - i(t);
          return d3.svg.arc()
            .innerRadius(function(d) { if (d.age && i(t) > 0) return d.radius+d.stroke+1; else return 0; })
            .outerRadius(function(d) { if (d.age && i(t) > 0) return d.radius+d.stroke+3; else return 0; })
            .startAngle(0).endAngle(i(t)*2*Math.PI)(d);
        }
      });
  }
}
d3viz();
</script>

<div id="edit_dialog" class="edit_dialog">
  <div>
    <form>
    <textarea id="edit_dialog_text"></textarea><br />
    <input type="button" id="edit_dialog_button" value="Edit" />
    </form>
    <div id="edit_close_button">x</div>
  </div>
</div>

<div id="graph_navigation">
  <div id="recenter" title="Center"><%= image_tag("center.svg", :border => 0) %></div>
  <div id="drag" title="Enable Dragging"><%= image_tag("move.svg", :border => 0) %></div>
  <!-- <div id="collapse" title="Collapse"><%= image_tag("sun.svg", :border => 0) %></div> -->
  <!-- <div id="loading"><%= image_tag("refresh.svg", :border => 0) %></div> -->
</div>

<footer class="floating_footer">
  <%= link_to 'Back', storylines_path %> · 
  <%= link_to 'Story View', @storyline %>
</footer>